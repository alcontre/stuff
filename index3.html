<style>
    html,
    body {
        margin: 0;
        padding: 0;
        height: 100%;
    }

    .myAAAcontainer {
        display: flex;
        align-items: flex-start;
        min-height: 100vh;
        width: 100%;
        overflow: visible;
    }

    .myAAAcontainer nav {
        width: 260px;
        position: sticky;
        top: 0;
        max-height: 100vh;
        border-right: 1px solid #ccc;
        padding: 1rem;
        overflow-y: auto;
        background-color: #2c3e50;
        color: #ecf0f1;
    }

    .myAAAcontainer nav h2 {
        margin-top: 0;
    }

    .myAAAcontainer nav a {
        color: #3498db;
        text-decoration: none;
    }

    .myAAAcontainer nav a:hover {
        color: #5dade2;
        text-decoration: underline;
    }

    .myAAAcontainer main {
        flex: 1;
        padding: 1.5rem;
        min-height: 100vh;
        overflow: visible;
    }

    .myAAAcontainer main h1 {
        margin-top: 0;
    }

    .myAAAcontainer main details summary span {
        display: inline;
        margin: 0;
        padding: 0;
        font-weight: bold;
    }

    .myAAAcontainer main details {
        margin: 1rem 0;
    }

    .myAAAcontainer main details summary {
        cursor: pointer;
        font-weight: bold;
        padding: 0.5em;
        list-style: none;
    }

    /* We use ::before rather than ::marker because confluence HTML Include
    appears to strip out ::marker*/
    .myAAAcontainer main details summary::before {
        content: '▶ ';
        display: inline-block;
        width: 1em;
        text-align: center;
        font-family: monospace;
    }

    .myAAAcontainer main details[open]>summary::before {
        content: '▼ ';
    }

    .myAAAcontainer main details>*:not(summary) {
        margin-left: 1.5rem;
    }

    .myAAAcontainer nav details {
        margin: 0.5rem 0;
    }

    /* The nav pane consists of summary/detail elements mirroring the main panel,
    and divs for leaf nodes (which do not have the ::before arrow) */
    .myAAAcontainer nav details summary,
    .myAAAcontainer nav div {
        cursor: pointer;
        font-weight: bold;
        padding: 0.25em 0;
        list-style: none;
    }

    .myAAAcontainer nav a.active {
        color: #e74c3c;
        font-weight: bold;
        background-color: rgba(231, 76, 60, 0.1);
        padding: 0.25em 0.5em;
        border-radius: 3px;
    }

    .myAAAcontainer nav details summary::before {
        content: '▶ ';
        display: inline-block;
        width: 1em;
        text-align: center;
        font-family: monospace;
    }

    .myAAAcontainer nav details[open]>summary::before {
        content: '▼ ';
    }

    /* Indentation for nested elements ("details") */
    .myAAAcontainer nav details>*:not(summary) {
        margin-left: 1.5rem;
    }

    script {
        display: none;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const mainElement = document.querySelector('.myAAAcontainer main');

        // Number all sections recursively
        function numberSections(parent, prefix = '') {
            const childDetails = Array.from(parent.children).filter(child => child.tagName === 'DETAILS');

            childDetails.forEach((detail, index) => {
                const sectionNum = prefix ? `${prefix}-${index + 1}` : String(index + 1);
                const titleSpan = detail.querySelector(':scope > summary span');
                const titleText = titleSpan ? titleSpan.textContent.trim() : '';

                // Update ID
                detail.id = `myAAA${sectionNum}`;

                // Update span with section number
                if (titleSpan) {
                    titleSpan.textContent = `${sectionNum.replace(/-/g, '.')} ${titleText}`;
                }

                // Recursively number child sections
                numberSections(detail, sectionNum);
            });
        }

        // Number all sections first
        numberSections(mainElement);

        // Find all details elements in main and build nav
        function buildNav(parent, targetContainer) {
            const childDetails = Array.from(parent.children).filter(child => child.tagName === 'DETAILS');

            childDetails.forEach(detail => {
                const titleSpan = detail.querySelector(':scope > summary span');
                const id = detail.id;
                const text = titleSpan ? titleSpan.textContent : '';

                // Check if original detail has child details
                const nestedDetails = Array.from(detail.children).filter(child => child.tagName === 'DETAILS');

                if (nestedDetails.length > 0) {
                    // Parent node - create details element
                    const detailsNav = document.createElement('details');
                    const summaryNav = document.createElement('summary');
                    const link = document.createElement('a');

                    link.href = '#' + id;
                    link.textContent = text;
                    summaryNav.appendChild(link);
                    detailsNav.appendChild(summaryNav);
                    detailsNav.setAttribute('open', '');

                    // Recursively build nav for nested details
                    buildNav(detail, detailsNav);
                    targetContainer.appendChild(detailsNav);
                } else {
                    // Leaf node - just create a link in a div
                    const leafDiv = document.createElement('div');
                    const link = document.createElement('a');
                    link.href = '#' + id;
                    link.textContent = text;
                    leafDiv.appendChild(link);
                    targetContainer.appendChild(leafDiv);
                }
            });
        }

        // Build navigation from numbered sections
        const navContainer = document.createElement('div');
        navContainer.id = 'myAAAnavContainer';
        buildNav(mainElement, navContainer);

        // Insert the generated nav before the main details
        const navElement = document.querySelector('.myAAAcontainer nav');
        const mainFirstChild = navElement.querySelector('h2').nextSibling;
        if (mainFirstChild) {
            mainFirstChild.parentNode.insertBefore(navContainer, mainFirstChild);
        } else {
            navElement.appendChild(navContainer);
        }

        // Function to open a details element and all its parent details
        function openDetailsAndParents(element) {
            let current = element;
            while (current && current !== document.body) {
                if (current.tagName === 'DETAILS') {
                    current.setAttribute('open', '');
                }
                current = current.parentElement;
            }
        }

        // Handle hash navigation to expand collapsed details
        function handleHashChange() {
            const hash = window.location.hash;
            if (hash) {
                const target = document.querySelector(hash);
                if (target) {
                    openDetailsAndParents(target);
                    highlightActiveLink();
                }
            }
        }

        // Scroll tracking to highlight active section in nav
        const mainContent = document.querySelector('.myAAAcontainer main');
        const mainDetails = Array.from(document.querySelectorAll('.myAAAcontainer main details'));

        function isDetailVisible(detail) {
            if (!detail) return false;
            let current = detail.parentElement;
            while (current && current !== document.body) {
                if (current.tagName === 'DETAILS' && !current.open) {
                    return false; // Hidden by a collapsed ancestor
                }
                current = current.parentElement;
            }
            return true;
        }

        function findActiveSection() {
            const scrollTop = window.scrollY;
            let bestAbove = null;

            mainDetails.forEach(detail => {
                if (!detail.id) return;
                if (!isDetailVisible(detail)) return;
                const rect = detail.getBoundingClientRect();
                const offset = rect.top + window.scrollY;

                if (offset <= scrollTop + 200) {
                    if (!bestAbove || offset > bestAbove.offset) {
                        bestAbove = { detail, offset };
                    }
                }
            });

            return bestAbove ? bestAbove.detail : null;
        }

        // Returns false if any ancestor details is collapsed;
        // used to avoid highlighting hidden nav items
        function isNavLinkVisible(link) {
            let current = link.parentElement;
            while (current && current !== document.body) {
                if (current.tagName === 'DETAILS' && !current.open) {
                    return false;
                }
                current = current.parentElement;
            }
            return true;
        }

        function highlightActiveLink() {
            const activeDetail = findActiveSection();
            const navLinks = document.querySelectorAll('.myAAAcontainer nav a');
            navLinks.forEach(link => link.classList.remove('active'));

            if (activeDetail && activeDetail.id) {
                const activeLink = document.querySelector(`.myAAAcontainer nav a[href="#${activeDetail.id}"]`);
                if (activeLink && isNavLinkVisible(activeLink)) {
                    activeLink.classList.add('active');
                }
            }
        }

        // Throttle scroll events using requestAnimationFrame
        let ticking = false;
        function onScroll() {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    highlightActiveLink();
                    ticking = false;
                });
            }
        }

        // Listen to window scroll since the main element scrolls with the page
        window.addEventListener('scroll', onScroll);

        // Listen for hash changes after scroll/highlight utilities are ready
        window.addEventListener('hashchange', handleHashChange);

        // Handle initial hash on page load
        handleHashChange();
        highlightActiveLink();

        // Call once on load to highlight the initial section
        setTimeout(() => {
            highlightActiveLink();
        }, 100);
    });
</script>
<div class="myAAAcontainer">
    <nav aria-label="Navigation">
        <h2>Sections</h2>
    </nav>

    <main>
        <h1>Binary Data Format Description</h1>
        <details open>
            <summary><span>File Header</span></summary>
            <p>The file header contains metadata about the binary format structure and version.</p>

            <details open>
                <summary><span>Signature</span></summary>
                <p>Magic bytes indicating format identity.</p>
            </details>

            <details open>
                <summary><span>Version</span></summary>
                <p>16-bit integer identifying schema revision.</p>
            </details>
        </details>

        <details open>
            <summary><span>Chunk Table</span></summary>
            <p>The chunk table provides an index of all data chunks within the file.</p>

            <details open>
                <summary><span>Chunk Entry</span></summary>
                <p>Repeated entries describing each payload chunk.</p>

                <details open>
                    <summary><span>Chunk Type</span></summary>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                    <p>Enumerated value describing purpose.</p>
                </details>

                <details open>
                    <summary><span>Chunk Offset</span></summary>
                    <p>32-bit offset from file start.</p>
                </details>

                <details open>
                    <summary><span>Chunk Size</span></summary>
                    <p>32-bit length in bytes.</p>
                </details>
            </details>
        </details>

        <details open>
            <summary><span>Payload</span></summary>
            <p>The payload section contains the actual data content organized into structured blocks.</p>

            <details open>
                <summary><span>Metadata Block</span></summary>
                <p>Optional key/value pairs with UTF-8 strings.</p>
            </details>

            <details open>
                <summary><span>Data Block</span></summary>
                <p>One or more records of the primary content.</p>

                <details open>
                    <summary><span>Record Header</span></summary>
                    <p>Flags and length for each record.</p>
                </details>

                <details open>
                    <summary><span>Record Body</span></summary>
                    <p>Raw bytes interpreted per chunk type.</p>
                </details>
            </details>
        </details>
    </main>
</div>